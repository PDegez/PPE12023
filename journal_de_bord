Programmation et projet encadré

#exercice/actions
?? question
!! remarque

COURS D'INTRODUCTION

1 - linux => tout est fichier et donc manipulable
    -> importance d'être organisé sur sa machine pour éviter un bazar absolu et des difficultés de manipulation : garder une arborescence propre.
2 - chemin absolu vers un fichier (chemin depuis /root)
vs chemin relatif (chemin depuis autre répertoire que /root : /home, ~/, répertoire courant etc...)
3 - Dossier > fichier
4 - commandes principales de navigation (voir slides 00-Shell)
5 - présentation de git (gestion de versions : permet de conserver les différentes versions d'un projet)

#exercice de tri de fichier par ligne de commande. Utilisation de mkdir, mv, et de la wildcard *

?? est-il possible d'automatiser le procédé en créant une boucle pour éviter de devoir modifier systématiquement un caractère avant de pouvoir bouger les fichiers (01,02,03...) ??


SEMAINE 2 : UTILISER GIT

1 - création d'un jeu de clé de sécurité ssh encodage ed25519
    - une clé publique (signature des actions publiques)
    - une clé personnelle (non communiquée avec l'exterieur, sécurisation des données lors des échanges avec git)
    - un code est joint est est demandé par git avant les manipulations qui modifient le répertoire
2 - syntaxe des commandes git : git <sous commande> [-options...] [arguments...]
3 - clonage du git du cours sur la machine afin de pouvoir récupérer les différents contenus via git
4 - mise à jour de la version locale à partir de la version en ligne :
    - git fetch (cherche le log pour répertorier les changements)
    - git pull (récupère les changements vers le répertoire local)
5 - ajout de fichier local sur la version en ligne :
    - git add (fichier à uploader)
    - git commit [-m message] (regroupement des derniers add)
    - git push (upload des changement indiqués par le dernier commit)
6 - ajout de tag (mettre en avant certains commits pour indiquer une étape importante)
    - git tag [-a] [-m message] <tagname> [commit]
    [-a] ajout d'un message
    [commit] indique le commit à tagger (sinon, dernier commit)
!! espace non accepté dans le nom du tag
7 - état du git :
    - git status
    - git log

#exercice : clonage de notre git personnel sur la machine
#exercice : push modification du journal de bord et de l'exercice de la session d'introduction
#perso : installation et configuration de powertop pour optimiser la vie de la batterie sur ubuntu
#perso : modification du nom de fichier pour éviter les espaces et les majuscules

SEMAINE 3 : CORRIGER UNE ERREUR SUR GIT

3 états de git :
    -> Modified means that you have changed the file but have not committed it to your database yet.
    -> Staged means that you have marked a modified file in its current version to go into your next commit snapshot.
    -> Committed means that the data is safely stored in your local database

Deux moyens différents pour corriger des erreurs sur git :
    - git reset : pour reset des commits non poussés (défaire les changements non partagés en ligne)
            git reset HEAD~[N] :    annule des changements NON COMMITE
            -> revient à la version -N du dépôt (par défaut, N=1, cad le commit parent)
            -> répertoire inchangé
            -> annule la mise en place (staging = liste de add)
            git reset --soft HEAD~
            -> revient à la version HEAD
            -> répertoire inchangé
            -> n'annule pas le staging
            git reset --hard HEAD~
            -> revient à la version HEAD
            -> répertoire changé pour correspondre à la version HEAD
            -> annule le staging
            git reset <commit> (commit = un tag ou un identifiant commit)
            -> revenir à un commit spécifique (soft et hard s'appliquent de la même façon)
    - git revert <commit> : annuler des changements commités
    crée un nouveau commit ou les changements sont annulés (conserve une trace des commits effectués)

#Exercice : fichier "oups" avait été commit+push par erreur en cours. A été remove du git par la suite.
#Exercice refait tel qu'il aurait dû avoir lieu :
1 - fichier oups créé en local
2 - fichier oups modifié à la place du journal en local
3 - fichier oups commité
4 - git revert git-seance3-init
5 - copier coller modifications de oups dans journal de bord. Add ces changements
6 - git commit -a -m "séance3, version finale des exercices de git"
7 - push




